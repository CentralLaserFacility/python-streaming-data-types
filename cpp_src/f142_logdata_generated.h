// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_F142LOGDATA_H_
#define FLATBUFFERS_GENERATED_F142LOGDATA_H_

#include "flatbuffers/flatbuffers.h"

struct Byte;
struct ByteBuilder;

struct UByte;
struct UByteBuilder;

struct Short;
struct ShortBuilder;

struct UShort;
struct UShortBuilder;

struct Int;
struct IntBuilder;

struct UInt;
struct UIntBuilder;

struct Long;
struct LongBuilder;

struct ULong;
struct ULongBuilder;

struct Float;
struct FloatBuilder;

struct Double;
struct DoubleBuilder;

struct ArrayByte;
struct ArrayByteBuilder;

struct ArrayUByte;
struct ArrayUByteBuilder;

struct ArrayShort;
struct ArrayShortBuilder;

struct ArrayUShort;
struct ArrayUShortBuilder;

struct ArrayInt;
struct ArrayIntBuilder;

struct ArrayUInt;
struct ArrayUIntBuilder;

struct ArrayLong;
struct ArrayLongBuilder;

struct ArrayULong;
struct ArrayULongBuilder;

struct ArrayFloat;
struct ArrayFloatBuilder;

struct ArrayDouble;
struct ArrayDoubleBuilder;

struct LogData;
struct LogDataBuilder;

enum Value : uint8_t {
  Value_NONE = 0,
  Value_Byte = 1,
  Value_UByte = 2,
  Value_Short = 3,
  Value_UShort = 4,
  Value_Int = 5,
  Value_UInt = 6,
  Value_Long = 7,
  Value_ULong = 8,
  Value_Float = 9,
  Value_Double = 10,
  Value_ArrayByte = 11,
  Value_ArrayUByte = 12,
  Value_ArrayShort = 13,
  Value_ArrayUShort = 14,
  Value_ArrayInt = 15,
  Value_ArrayUInt = 16,
  Value_ArrayLong = 17,
  Value_ArrayULong = 18,
  Value_ArrayFloat = 19,
  Value_ArrayDouble = 20,
  Value_MIN = Value_NONE,
  Value_MAX = Value_ArrayDouble
};

inline const Value (&EnumValuesValue())[21] {
  static const Value values[] = {
    Value_NONE,
    Value_Byte,
    Value_UByte,
    Value_Short,
    Value_UShort,
    Value_Int,
    Value_UInt,
    Value_Long,
    Value_ULong,
    Value_Float,
    Value_Double,
    Value_ArrayByte,
    Value_ArrayUByte,
    Value_ArrayShort,
    Value_ArrayUShort,
    Value_ArrayInt,
    Value_ArrayUInt,
    Value_ArrayLong,
    Value_ArrayULong,
    Value_ArrayFloat,
    Value_ArrayDouble
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[22] = {
    "NONE",
    "Byte",
    "UByte",
    "Short",
    "UShort",
    "Int",
    "UInt",
    "Long",
    "ULong",
    "Float",
    "Double",
    "ArrayByte",
    "ArrayUByte",
    "ArrayShort",
    "ArrayUShort",
    "ArrayInt",
    "ArrayUInt",
    "ArrayLong",
    "ArrayULong",
    "ArrayFloat",
    "ArrayDouble",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (flatbuffers::IsOutRange(e, Value_NONE, Value_ArrayDouble)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value_NONE;
};

template<> struct ValueTraits<Byte> {
  static const Value enum_value = Value_Byte;
};

template<> struct ValueTraits<UByte> {
  static const Value enum_value = Value_UByte;
};

template<> struct ValueTraits<Short> {
  static const Value enum_value = Value_Short;
};

template<> struct ValueTraits<UShort> {
  static const Value enum_value = Value_UShort;
};

template<> struct ValueTraits<Int> {
  static const Value enum_value = Value_Int;
};

template<> struct ValueTraits<UInt> {
  static const Value enum_value = Value_UInt;
};

template<> struct ValueTraits<Long> {
  static const Value enum_value = Value_Long;
};

template<> struct ValueTraits<ULong> {
  static const Value enum_value = Value_ULong;
};

template<> struct ValueTraits<Float> {
  static const Value enum_value = Value_Float;
};

template<> struct ValueTraits<Double> {
  static const Value enum_value = Value_Double;
};

template<> struct ValueTraits<ArrayByte> {
  static const Value enum_value = Value_ArrayByte;
};

template<> struct ValueTraits<ArrayUByte> {
  static const Value enum_value = Value_ArrayUByte;
};

template<> struct ValueTraits<ArrayShort> {
  static const Value enum_value = Value_ArrayShort;
};

template<> struct ValueTraits<ArrayUShort> {
  static const Value enum_value = Value_ArrayUShort;
};

template<> struct ValueTraits<ArrayInt> {
  static const Value enum_value = Value_ArrayInt;
};

template<> struct ValueTraits<ArrayUInt> {
  static const Value enum_value = Value_ArrayUInt;
};

template<> struct ValueTraits<ArrayLong> {
  static const Value enum_value = Value_ArrayLong;
};

template<> struct ValueTraits<ArrayULong> {
  static const Value enum_value = Value_ArrayULong;
};

template<> struct ValueTraits<ArrayFloat> {
  static const Value enum_value = Value_ArrayFloat;
};

template<> struct ValueTraits<ArrayDouble> {
  static const Value enum_value = Value_ArrayDouble;
};

bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum AlarmStatus : uint16_t {
  AlarmStatus_NO_ALARM = 0,
  AlarmStatus_READ = 1,
  AlarmStatus_WRITE = 2,
  AlarmStatus_HIHI = 3,
  AlarmStatus_HIGH = 4,
  AlarmStatus_LOLO = 5,
  AlarmStatus_LOW = 6,
  AlarmStatus_STATE = 7,
  AlarmStatus_COS = 8,
  AlarmStatus_COMM = 9,
  AlarmStatus_TIMED = 10,
  AlarmStatus_HWLIMIT = 11,
  AlarmStatus_CALC = 12,
  AlarmStatus_SCAN = 13,
  AlarmStatus_LINK = 14,
  AlarmStatus_SOFT = 15,
  AlarmStatus_BAD_SUB = 16,
  AlarmStatus_UDF = 17,
  AlarmStatus_DISABLE = 18,
  AlarmStatus_SIMM = 19,
  AlarmStatus_READ_ACCESS = 20,
  AlarmStatus_WRITE_ACCESS = 21,
  AlarmStatus_NO_CHANGE = 22,
  AlarmStatus_MIN = AlarmStatus_NO_ALARM,
  AlarmStatus_MAX = AlarmStatus_NO_CHANGE
};

inline const AlarmStatus (&EnumValuesAlarmStatus())[23] {
  static const AlarmStatus values[] = {
    AlarmStatus_NO_ALARM,
    AlarmStatus_READ,
    AlarmStatus_WRITE,
    AlarmStatus_HIHI,
    AlarmStatus_HIGH,
    AlarmStatus_LOLO,
    AlarmStatus_LOW,
    AlarmStatus_STATE,
    AlarmStatus_COS,
    AlarmStatus_COMM,
    AlarmStatus_TIMED,
    AlarmStatus_HWLIMIT,
    AlarmStatus_CALC,
    AlarmStatus_SCAN,
    AlarmStatus_LINK,
    AlarmStatus_SOFT,
    AlarmStatus_BAD_SUB,
    AlarmStatus_UDF,
    AlarmStatus_DISABLE,
    AlarmStatus_SIMM,
    AlarmStatus_READ_ACCESS,
    AlarmStatus_WRITE_ACCESS,
    AlarmStatus_NO_CHANGE
  };
  return values;
}

inline const char * const *EnumNamesAlarmStatus() {
  static const char * const names[24] = {
    "NO_ALARM",
    "READ",
    "WRITE",
    "HIHI",
    "HIGH",
    "LOLO",
    "LOW",
    "STATE",
    "COS",
    "COMM",
    "TIMED",
    "HWLIMIT",
    "CALC",
    "SCAN",
    "LINK",
    "SOFT",
    "BAD_SUB",
    "UDF",
    "DISABLE",
    "SIMM",
    "READ_ACCESS",
    "WRITE_ACCESS",
    "NO_CHANGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAlarmStatus(AlarmStatus e) {
  if (flatbuffers::IsOutRange(e, AlarmStatus_NO_ALARM, AlarmStatus_NO_CHANGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAlarmStatus()[index];
}

enum AlarmSeverity : uint16_t {
  AlarmSeverity_MINOR = 0,
  AlarmSeverity_MAJOR = 1,
  AlarmSeverity_NO_ALARM = 2,
  AlarmSeverity_INVALID = 3,
  AlarmSeverity_NO_CHANGE = 4,
  AlarmSeverity_MIN = AlarmSeverity_MINOR,
  AlarmSeverity_MAX = AlarmSeverity_NO_CHANGE
};

inline const AlarmSeverity (&EnumValuesAlarmSeverity())[5] {
  static const AlarmSeverity values[] = {
    AlarmSeverity_MINOR,
    AlarmSeverity_MAJOR,
    AlarmSeverity_NO_ALARM,
    AlarmSeverity_INVALID,
    AlarmSeverity_NO_CHANGE
  };
  return values;
}

inline const char * const *EnumNamesAlarmSeverity() {
  static const char * const names[6] = {
    "MINOR",
    "MAJOR",
    "NO_ALARM",
    "INVALID",
    "NO_CHANGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAlarmSeverity(AlarmSeverity e) {
  if (flatbuffers::IsOutRange(e, AlarmSeverity_MINOR, AlarmSeverity_NO_CHANGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAlarmSeverity()[index];
}

struct Byte FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ByteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct ByteBuilder {
  typedef Byte Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(Byte::VT_VALUE, value, 0);
  }
  explicit ByteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Byte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Byte>(end);
    return o;
  }
};

inline flatbuffers::Offset<Byte> CreateByte(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  ByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UByte FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UByteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct UByteBuilder {
  typedef UByte Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(UByte::VT_VALUE, value, 0);
  }
  explicit UByteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UByte>(end);
    return o;
  }
};

inline flatbuffers::Offset<UByte> CreateUByte(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  UByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Short FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShortBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct ShortBuilder {
  typedef Short Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Short::VT_VALUE, value, 0);
  }
  explicit ShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Short> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Short>(end);
    return o;
  }
};

inline flatbuffers::Offset<Short> CreateShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  ShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UShort FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UShortBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct UShortBuilder {
  typedef UShort Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(UShort::VT_VALUE, value, 0);
  }
  explicit UShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UShort>(end);
    return o;
  }
};

inline flatbuffers::Offset<UShort> CreateUShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  UShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct UIntBuilder {
  typedef UInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(UInt::VT_VALUE, value, 0);
  }
  explicit UIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt> CreateUInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  UIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Long FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct LongBuilder {
  typedef Long Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Long::VT_VALUE, value, 0);
  }
  explicit LongBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Long> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Long>(end);
    return o;
  }
};

inline flatbuffers::Offset<Long> CreateLong(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  LongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ULong FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ULongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct ULongBuilder {
  typedef ULong Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(ULong::VT_VALUE, value, 0);
  }
  explicit ULongBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ULong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ULong>(end);
    return o;
  }
};

inline flatbuffers::Offset<ULong> CreateULong(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  ULongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct FloatBuilder {
  typedef Float Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(Float::VT_VALUE, value, 0.0f);
  }
  explicit FloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float> CreateFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  FloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ArrayByte FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayByteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayByteBuilder {
  typedef ArrayByte Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(ArrayByte::VT_VALUE, value);
  }
  explicit ArrayByteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayByte>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayByte> CreateArrayByte(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  ArrayByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayByte> CreateArrayByteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return CreateArrayByte(
      _fbb,
      value__);
}

struct ArrayUByte FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayUByteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayUByteBuilder {
  typedef ArrayUByte Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(ArrayUByte::VT_VALUE, value);
  }
  explicit ArrayUByteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayUByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayUByte>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayUByte> CreateArrayUByte(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  ArrayUByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayUByte> CreateArrayUByteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return CreateArrayUByte(
      _fbb,
      value__);
}

struct ArrayShort FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayShortBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int16_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayShortBuilder {
  typedef ArrayShort Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int16_t>> value) {
    fbb_.AddOffset(ArrayShort::VT_VALUE, value);
  }
  explicit ArrayShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayShort>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayShort> CreateArrayShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> value = 0) {
  ArrayShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayShort> CreateArrayShortDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int16_t>(*value) : 0;
  return CreateArrayShort(
      _fbb,
      value__);
}

struct ArrayUShort FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayUShortBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint16_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayUShortBuilder {
  typedef ArrayUShort Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> value) {
    fbb_.AddOffset(ArrayUShort::VT_VALUE, value);
  }
  explicit ArrayUShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayUShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayUShort>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayUShort> CreateArrayUShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> value = 0) {
  ArrayUShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayUShort> CreateArrayUShortDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint16_t>(*value) : 0;
  return CreateArrayUShort(
      _fbb,
      value__);
}

struct ArrayInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayIntBuilder {
  typedef ArrayInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(ArrayInt::VT_VALUE, value);
  }
  explicit ArrayIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayInt> CreateArrayInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  ArrayIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayInt> CreateArrayIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return CreateArrayInt(
      _fbb,
      value__);
}

struct ArrayUInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayUIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayUIntBuilder {
  typedef ArrayUInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value) {
    fbb_.AddOffset(ArrayUInt::VT_VALUE, value);
  }
  explicit ArrayUIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayUInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayUInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayUInt> CreateArrayUInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value = 0) {
  ArrayUIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayUInt> CreateArrayUIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint32_t>(*value) : 0;
  return CreateArrayUInt(
      _fbb,
      value__);
}

struct ArrayLong FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayLongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayLongBuilder {
  typedef ArrayLong Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(ArrayLong::VT_VALUE, value);
  }
  explicit ArrayLongBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayLong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayLong>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayLong> CreateArrayLong(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> value = 0) {
  ArrayLongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayLong> CreateArrayLongDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int64_t>(*value) : 0;
  return CreateArrayLong(
      _fbb,
      value__);
}

struct ArrayULong FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayULongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayULongBuilder {
  typedef ArrayULong Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> value) {
    fbb_.AddOffset(ArrayULong::VT_VALUE, value);
  }
  explicit ArrayULongBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayULong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayULong>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayULong> CreateArrayULong(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> value = 0) {
  ArrayULongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayULong> CreateArrayULongDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint64_t>(*value) : 0;
  return CreateArrayULong(
      _fbb,
      value__);
}

struct ArrayFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayFloatBuilder {
  typedef ArrayFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(ArrayFloat::VT_VALUE, value);
  }
  explicit ArrayFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayFloat> CreateArrayFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  ArrayFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayFloat> CreateArrayFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return CreateArrayFloat(
      _fbb,
      value__);
}

struct ArrayDouble FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayDoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<double> *value() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayDoubleBuilder {
  typedef ArrayDouble Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(ArrayDouble::VT_VALUE, value);
  }
  explicit ArrayDoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayDouble>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayDouble> CreateArrayDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> value = 0) {
  ArrayDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayDouble> CreateArrayDoubleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<double>(*value) : 0;
  return CreateArrayDouble(
      _fbb,
      value__);
}

struct LogData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_TIMESTAMP = 10,
    VT_STATUS = 12,
    VT_SEVERITY = 14
  };
  const flatbuffers::String *source_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_NAME);
  }
  Value value_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Byte *value_as_Byte() const {
    return value_type() == Value_Byte ? static_cast<const Byte *>(value()) : nullptr;
  }
  const UByte *value_as_UByte() const {
    return value_type() == Value_UByte ? static_cast<const UByte *>(value()) : nullptr;
  }
  const Short *value_as_Short() const {
    return value_type() == Value_Short ? static_cast<const Short *>(value()) : nullptr;
  }
  const UShort *value_as_UShort() const {
    return value_type() == Value_UShort ? static_cast<const UShort *>(value()) : nullptr;
  }
  const Int *value_as_Int() const {
    return value_type() == Value_Int ? static_cast<const Int *>(value()) : nullptr;
  }
  const UInt *value_as_UInt() const {
    return value_type() == Value_UInt ? static_cast<const UInt *>(value()) : nullptr;
  }
  const Long *value_as_Long() const {
    return value_type() == Value_Long ? static_cast<const Long *>(value()) : nullptr;
  }
  const ULong *value_as_ULong() const {
    return value_type() == Value_ULong ? static_cast<const ULong *>(value()) : nullptr;
  }
  const Float *value_as_Float() const {
    return value_type() == Value_Float ? static_cast<const Float *>(value()) : nullptr;
  }
  const Double *value_as_Double() const {
    return value_type() == Value_Double ? static_cast<const Double *>(value()) : nullptr;
  }
  const ArrayByte *value_as_ArrayByte() const {
    return value_type() == Value_ArrayByte ? static_cast<const ArrayByte *>(value()) : nullptr;
  }
  const ArrayUByte *value_as_ArrayUByte() const {
    return value_type() == Value_ArrayUByte ? static_cast<const ArrayUByte *>(value()) : nullptr;
  }
  const ArrayShort *value_as_ArrayShort() const {
    return value_type() == Value_ArrayShort ? static_cast<const ArrayShort *>(value()) : nullptr;
  }
  const ArrayUShort *value_as_ArrayUShort() const {
    return value_type() == Value_ArrayUShort ? static_cast<const ArrayUShort *>(value()) : nullptr;
  }
  const ArrayInt *value_as_ArrayInt() const {
    return value_type() == Value_ArrayInt ? static_cast<const ArrayInt *>(value()) : nullptr;
  }
  const ArrayUInt *value_as_ArrayUInt() const {
    return value_type() == Value_ArrayUInt ? static_cast<const ArrayUInt *>(value()) : nullptr;
  }
  const ArrayLong *value_as_ArrayLong() const {
    return value_type() == Value_ArrayLong ? static_cast<const ArrayLong *>(value()) : nullptr;
  }
  const ArrayULong *value_as_ArrayULong() const {
    return value_type() == Value_ArrayULong ? static_cast<const ArrayULong *>(value()) : nullptr;
  }
  const ArrayFloat *value_as_ArrayFloat() const {
    return value_type() == Value_ArrayFloat ? static_cast<const ArrayFloat *>(value()) : nullptr;
  }
  const ArrayDouble *value_as_ArrayDouble() const {
    return value_type() == Value_ArrayDouble ? static_cast<const ArrayDouble *>(value()) : nullptr;
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  AlarmStatus status() const {
    return static_cast<AlarmStatus>(GetField<uint16_t>(VT_STATUS, 22));
  }
  AlarmSeverity severity() const {
    return static_cast<AlarmSeverity>(GetField<uint16_t>(VT_SEVERITY, 4));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE_NAME) &&
           verifier.VerifyString(source_name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint16_t>(verifier, VT_STATUS, 2) &&
           VerifyField<uint16_t>(verifier, VT_SEVERITY, 2) &&
           verifier.EndTable();
  }
};

template<> inline const Byte *LogData::value_as<Byte>() const {
  return value_as_Byte();
}

template<> inline const UByte *LogData::value_as<UByte>() const {
  return value_as_UByte();
}

template<> inline const Short *LogData::value_as<Short>() const {
  return value_as_Short();
}

template<> inline const UShort *LogData::value_as<UShort>() const {
  return value_as_UShort();
}

template<> inline const Int *LogData::value_as<Int>() const {
  return value_as_Int();
}

template<> inline const UInt *LogData::value_as<UInt>() const {
  return value_as_UInt();
}

template<> inline const Long *LogData::value_as<Long>() const {
  return value_as_Long();
}

template<> inline const ULong *LogData::value_as<ULong>() const {
  return value_as_ULong();
}

template<> inline const Float *LogData::value_as<Float>() const {
  return value_as_Float();
}

template<> inline const Double *LogData::value_as<Double>() const {
  return value_as_Double();
}

template<> inline const ArrayByte *LogData::value_as<ArrayByte>() const {
  return value_as_ArrayByte();
}

template<> inline const ArrayUByte *LogData::value_as<ArrayUByte>() const {
  return value_as_ArrayUByte();
}

template<> inline const ArrayShort *LogData::value_as<ArrayShort>() const {
  return value_as_ArrayShort();
}

template<> inline const ArrayUShort *LogData::value_as<ArrayUShort>() const {
  return value_as_ArrayUShort();
}

template<> inline const ArrayInt *LogData::value_as<ArrayInt>() const {
  return value_as_ArrayInt();
}

template<> inline const ArrayUInt *LogData::value_as<ArrayUInt>() const {
  return value_as_ArrayUInt();
}

template<> inline const ArrayLong *LogData::value_as<ArrayLong>() const {
  return value_as_ArrayLong();
}

template<> inline const ArrayULong *LogData::value_as<ArrayULong>() const {
  return value_as_ArrayULong();
}

template<> inline const ArrayFloat *LogData::value_as<ArrayFloat>() const {
  return value_as_ArrayFloat();
}

template<> inline const ArrayDouble *LogData::value_as<ArrayDouble>() const {
  return value_as_ArrayDouble();
}

struct LogDataBuilder {
  typedef LogData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_name(flatbuffers::Offset<flatbuffers::String> source_name) {
    fbb_.AddOffset(LogData::VT_SOURCE_NAME, source_name);
  }
  void add_value_type(Value value_type) {
    fbb_.AddElement<uint8_t>(LogData::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(LogData::VT_VALUE, value);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(LogData::VT_TIMESTAMP, timestamp, 0);
  }
  void add_status(AlarmStatus status) {
    fbb_.AddElement<uint16_t>(LogData::VT_STATUS, static_cast<uint16_t>(status), 22);
  }
  void add_severity(AlarmSeverity severity) {
    fbb_.AddElement<uint16_t>(LogData::VT_SEVERITY, static_cast<uint16_t>(severity), 4);
  }
  explicit LogDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogData> CreateLogData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> source_name = 0,
    Value value_type = Value_NONE,
    flatbuffers::Offset<void> value = 0,
    uint64_t timestamp = 0,
    AlarmStatus status = AlarmStatus_NO_CHANGE,
    AlarmSeverity severity = AlarmSeverity_NO_CHANGE) {
  LogDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_value(value);
  builder_.add_source_name(source_name);
  builder_.add_severity(severity);
  builder_.add_status(status);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogData> CreateLogDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *source_name = nullptr,
    Value value_type = Value_NONE,
    flatbuffers::Offset<void> value = 0,
    uint64_t timestamp = 0,
    AlarmStatus status = AlarmStatus_NO_CHANGE,
    AlarmSeverity severity = AlarmSeverity_NO_CHANGE) {
  auto source_name__ = source_name ? _fbb.CreateString(source_name) : 0;
  return CreateLogData(
      _fbb,
      source_name__,
      value_type,
      value,
      timestamp,
      status,
      severity);
}

inline bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value_NONE: {
      return true;
    }
    case Value_Byte: {
      auto ptr = reinterpret_cast<const Byte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_UByte: {
      auto ptr = reinterpret_cast<const UByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Short: {
      auto ptr = reinterpret_cast<const Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_UShort: {
      auto ptr = reinterpret_cast<const UShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Int: {
      auto ptr = reinterpret_cast<const Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_UInt: {
      auto ptr = reinterpret_cast<const UInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Long: {
      auto ptr = reinterpret_cast<const Long *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ULong: {
      auto ptr = reinterpret_cast<const ULong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Float: {
      auto ptr = reinterpret_cast<const Float *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Double: {
      auto ptr = reinterpret_cast<const Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayByte: {
      auto ptr = reinterpret_cast<const ArrayByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayUByte: {
      auto ptr = reinterpret_cast<const ArrayUByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayShort: {
      auto ptr = reinterpret_cast<const ArrayShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayUShort: {
      auto ptr = reinterpret_cast<const ArrayUShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayInt: {
      auto ptr = reinterpret_cast<const ArrayInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayUInt: {
      auto ptr = reinterpret_cast<const ArrayUInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayLong: {
      auto ptr = reinterpret_cast<const ArrayLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayULong: {
      auto ptr = reinterpret_cast<const ArrayULong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayFloat: {
      auto ptr = reinterpret_cast<const ArrayFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ArrayDouble: {
      auto ptr = reinterpret_cast<const ArrayDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const LogData *GetLogData(const void *buf) {
  return flatbuffers::GetRoot<LogData>(buf);
}

inline const LogData *GetSizePrefixedLogData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<LogData>(buf);
}

inline const char *LogDataIdentifier() {
  return "f142";
}

inline bool LogDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, LogDataIdentifier());
}

inline bool SizePrefixedLogDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, LogDataIdentifier(), true);
}

inline bool VerifyLogDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LogData>(LogDataIdentifier());
}

inline bool VerifySizePrefixedLogDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LogData>(LogDataIdentifier());
}

inline void FinishLogDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<LogData> root) {
  fbb.Finish(root, LogDataIdentifier());
}

inline void FinishSizePrefixedLogDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<LogData> root) {
  fbb.FinishSizePrefixed(root, LogDataIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_F142LOGDATA_H_
